<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Visualizador AR - Hardware High Fidelity</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #050505; 
            font-family: 'Courier New', Courier, monospace; 
            user-select: none;
        }
        canvas { display: block; }
        
        /* UI Layer (HUD) */
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
            background: radial-gradient(circle, transparent 60%, rgba(0,0,0,0.8) 100%);
            transition: opacity 0.5s;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            color: #00ff88;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
        }

        .status-box {
            border-left: 3px solid #00ff88;
            padding-left: 15px;
            background: rgba(0, 20, 10, 0.6);
            backdrop-filter: blur(4px);
            border-radius: 0 8px 8px 0;
        }

        .component-tag {
            font-family: 'Segoe UI', sans-serif;
            font-weight: 800;
            color: #fff;
            font-size: 18px;
            margin-bottom: 5px;
            letter-spacing: 1px;
        }

        .sub-tag { color: #aaa; font-size: 11px; font-weight: 600; }
        
        /* Instruções AR */
        #ar-instructions {
            position: absolute;
            bottom: 100px; width: 100%;
            text-align: center;
            color: white; font-weight: bold;
            text-shadow: 0 1px 3px black;
            display: none;
            font-family: sans-serif;
            pointer-events: none;
        }

        #ar-warning {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            border: 1px solid red;
            color: white; padding: 20px;
            display: none; text-align: center;
            z-index: 999;
            border-radius: 8px;
        }

        .loading {
            position: absolute; top: 50%; left: 50%; 
            transform: translate(-50%, -50%);
            color: #00ff88; font-size: 14px; 
            background: rgba(0,0,0,0.8); padding: 20px;
            border: 1px solid #00ff88; z-index: 100;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="header">
            <div class="status-box">
                <div class="component-tag">AMD RYZEN™ 9</div>
                <div class="sub-tag">ESCALA REAL (1:1) / HIT-TEST</div>
            </div>
            <div style="text-align: right; color: white; font-size: 10px; opacity: 0.7;">
                AR CORE: ATIVO<br>SENSORS: LIGADOS
            </div>
        </div>
        <div style="text-align: center; color: rgba(255,255,255,0.5); margin-bottom: 80px; font-size: 10px;">
            MODO DE APRESENTAÇÃO TÉCNICA
        </div>
    </div>

    <div id="ar-instructions">APONTE PARA O CHÃO E TOQUE PARA POSICIONAR</div>

    <div id="ar-warning">
        ⚠️ <strong>Erro de Protocolo</strong><br><br>
        A câmera requer conexão segura (HTTPS).<br>
        Use o GitHub Pages ou localhost.
    </div>

    <div class="loading" id="loader">INICIALIZANDO SISTEMA...</div>

    <!-- Import Map -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { ARButton } from 'three/addons/webxr/ARButton.js';

        // Verificação HTTPS
        if (window.location.protocol !== 'https:' && window.location.hostname !== 'localhost' && window.location.hostname !== '127.0.0.1') {
            document.getElementById('ar-warning').style.display = 'block';
            document.getElementById('loader').style.display = 'none';
        }

        // --- VARIÁVEIS GLOBAIS ---
        let container;
        let camera, scene, renderer;
        let controller;
        let reticle; // A "mira" que detecta o chão
        let hitTestSource = null;
        let hitTestSourceRequested = false;
        let objectPlaced = false;
        let contentGroup; // Onde nosso hardware vai morar

        // --- 1. TEXTURAS PROCEDURAIS (PCB Realista) ---
        function createPCBTexture() {
            const size = 1024; // Alta resolução para ver de perto
            const canvas = document.createElement('canvas');
            canvas.width = size; canvas.height = size;
            const ctx = canvas.getContext('2d');
            
            // Base Epóxi Verde Escura
            ctx.fillStyle = '#0f2b1d'; 
            ctx.fillRect(0, 0, size, size);
            
            // Trilhas de Cobre (Submersas)
            ctx.strokeStyle = '#1a402b'; 
            ctx.lineWidth = 4;
            ctx.lineCap = 'square';
            for(let i=0; i<150; i++) {
                ctx.beginPath();
                const x = Math.random()*size;
                const y = Math.random()*size;
                ctx.moveTo(x, y);
                if(Math.random() > 0.5) ctx.lineTo(x + (Math.random()*200 - 100), y);
                else ctx.lineTo(x, y + (Math.random()*200 - 100));
                ctx.stroke();
            }
            
            // Pads de Solda Dourados
            ctx.fillStyle = '#cda865';
            for(let i=0; i<80; i++) {
                ctx.beginPath();
                ctx.arc(Math.random()*size, Math.random()*size, 3, 0, Math.PI*2);
                ctx.fill();
            }

            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping;
            tex.anisotropy = 16;
            return tex;
        }

        init();
        animate();

        function init() {
            container = document.createElement('div');
            document.body.appendChild(container);

            scene = new THREE.Scene();

            // Câmera configurada para escala humana
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);
            
            // --- ILUMINAÇÃO FOTOREALISTA ---
            // Luz Hemisférica para base suave (Céu azulado, chão terroso)
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 0.5);
            hemiLight.position.set(0, 1, 0);
            scene.add(hemiLight);

            // Luz Direcional com Sombras Suaves (Simulando Sol/Lâmpada forte)
            const dirLight = new THREE.DirectionalLight(0xffffff, 2.5);
            dirLight.position.set(0.5, 2, 0.5); // Vem de cima
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);

            // --- RENDERER ---
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true; // Essencial para WebXR
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping; // Melhor contraste
            renderer.toneMappingExposure = 1.2;
            container.appendChild(renderer.domElement);

            // Botão AR com "Hit Test" (Detectar superfície)
            let arButton = ARButton.createButton(renderer, { requiredFeatures: ['hit-test'] });
            document.body.appendChild(arButton);

            // --- CONTEÚDO 3D (ESCALA REAL: 1 unidade = 1 metro) ---
            contentGroup = new THREE.Group();
            contentGroup.visible = false; // Invisível até o usuário tocar na tela
            scene.add(contentGroup);

            // Materiais PBR Avançados
            const pcbTex = createPCBTexture();
            const matPCB = new THREE.MeshStandardMaterial({ 
                map: pcbTex, 
                roughness: 0.4, // Meio brilhante (verniz)
                metalness: 0.1 
            });
            const matIHS = new THREE.MeshStandardMaterial({ 
                color: 0xdddddd, 
                roughness: 0.25, // Alumínio fosco
                metalness: 0.9 
            }); 
            const matGold = new THREE.MeshStandardMaterial({ 
                color: 0xffd700, 
                roughness: 0.15, 
                metalness: 1.0 
            });
            const matFan = new THREE.MeshStandardMaterial({ 
                color: 0x111111, 
                roughness: 0.6 
            });
            const matRGB = new THREE.MeshStandardMaterial({ 
                color: 0x000000, 
                emissive: 0xff0033, 
                emissiveIntensity: 2.0 
            });

            // 1. Placa Mãe (Base de corte: 20cm x 20cm)
            // Geometria: 0.2m = 20cm
            const board = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.002, 0.2), matPCB);
            board.position.y = 0.001; // Levemente acima do chão
            board.receiveShadow = true;
            board.castShadow = true;
            contentGroup.add(board);

            // 2. Processador Ryzen (Tamanho Real: 40mm x 40mm)
            // 0.04m = 4cm
            const cpuGroup = new THREE.Group();
            
            // PCB do CPU
            const cpuBase = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.002, 0.04), matPCB);
            cpuGroup.add(cpuBase);
            
            // IHS (Metal) - Formato característico
            const ihs = new THREE.Mesh(new THREE.BoxGeometry(0.034, 0.004, 0.034), matIHS);
            ihs.position.y = 0.003;
            ihs.castShadow = true;
            cpuGroup.add(ihs);

            // Pinos/Contatos (Visual)
            cpuGroup.position.y = 0.015; // Posição inicial flutuando na animação
            contentGroup.add(cpuGroup);

            // 3. Cooler (Tamanho Real: ~12cm diâmetro)
            const coolerGroup = new THREE.Group();
            
            // Dissipador
            const heatsink = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 0.03, 64), matIHS);
            heatsink.position.y = 0.015;
            heatsink.castShadow = true;
            coolerGroup.add(heatsink);

            // Anel RGB
            const ring = new THREE.Mesh(new THREE.TorusGeometry(0.062, 0.002, 16, 64), matRGB);
            ring.rotation.x = Math.PI / 2;
            ring.position.y = 0.03;
            coolerGroup.add(ring);

            // Ventoinha
            const fanGeo = new THREE.BoxGeometry(0.11, 0.002, 0.02);
            const fanBlades = new THREE.Group();
            for(let i=0; i<7; i++) {
                const blade = new THREE.Mesh(fanGeo, matFan);
                blade.rotation.y = (i/7) * Math.PI * 2;
                fanBlades.add(blade);
            }
            fanBlades.position.y = 0.032;
            
            // Referência global para animação
            window.fanBlades = fanBlades;
            window.cpuGroup = cpuGroup;
            window.coolerGroup = coolerGroup;
            window.matRGB = matRGB;
            
            coolerGroup.add(fanBlades);
            coolerGroup.position.y = 0.05; // Acima do CPU
            contentGroup.add(coolerGroup);

            // --- RETÍCULO (MIRA DE AR) ---
            // Esse é o anel branco que mostra onde o objeto vai aparecer
            reticle = new THREE.Mesh(
                new THREE.RingGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2),
                new THREE.MeshBasicMaterial()
            );
            reticle.matrixAutoUpdate = false;
            reticle.visible = false; // Só aparece quando o AR detectar chão
            scene.add(reticle);

            // --- INTERAÇÃO (Toque na tela) ---
            controller = renderer.xr.getController(0);
            controller.addEventListener('select', onSelect);
            scene.add(controller);

            // OrbitControls para teste no PC (sem AR)
            const controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 0, 0);
            controls.update();

            window.addEventListener('resize', onWindowResize);
            document.getElementById('loader').style.display = 'none';
        }

        // Função chamada ao tocar na tela
        function onSelect() {
            if (reticle.visible) {
                // Posiciona o grupo no local do retículo
                contentGroup.position.setFromMatrixPosition(reticle.matrix);
                contentGroup.visible = true; // Mostra o objeto
                objectPlaced = true;
                
                // Esconde instruções
                document.getElementById('ar-instructions').style.display = 'none';
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- LOOP DE RENDERIZAÇÃO ---
        function animate() {
            renderer.setAnimationLoop(render);
        }

        function render(timestamp, frame) {
            const delta = timestamp / 1000;

            // Lógica do WebXR Hit Test (O coração do AR)
            if (frame) {
                const referenceSpace = renderer.xr.getReferenceSpace();
                const session = renderer.xr.getSession();

                if (hitTestSourceRequested === false) {
                    session.requestReferenceSpace('viewer').then(function (referenceSpace) {
                        session.requestHitTestSource({ space: referenceSpace }).then(function (source) {
                            hitTestSource = source;
                        });
                    });

                    session.addEventListener('end', function () {
                        hitTestSourceRequested = false;
                        hitTestSource = null;
                        document.getElementById('ar-instructions').style.display = 'none';
                        document.getElementById('ui-layer').style.display = 'flex';
                    });

                    hitTestSourceRequested = true;
                    
                    // Mostrar instruções ao iniciar AR
                    document.getElementById('ui-layer').style.display = 'none';
                    document.getElementById('ar-instructions').style.display = 'block';
                }

                if (hitTestSource) {
                    const hitTestResults = frame.getHitTestResults(hitTestSource);

                    if (hitTestResults.length > 0) {
                        const hit = hitTestResults[0];
                        // Coloca o retículo na posição da superfície detectada
                        reticle.visible = true;
                        reticle.matrix.fromArray(hit.getPose(referenceSpace).transform.matrix);
                    } else {
                        reticle.visible = false;
                    }
                }
            }

            // Animações do Hardware (Se estiver visível ou no modo PC)
            if (contentGroup.visible || !renderer.xr.isPresenting) {
                // 1. Ventoinha Girando
                if(window.fanBlades) window.fanBlades.rotation.y -= 0.2;

                // 2. LED RGB Pulsando
                if(window.matRGB) {
                    const hue = (delta * 0.2) % 1;
                    window.matRGB.emissive.setHSL(hue, 1, 0.5);
                }

                // 3. Vista Explodida (Sobe e desce suavemente)
                // Usamos escala real (metros), então os movimentos são pequenos (centímetros)
                const float = (Math.sin(delta * 1.5) + 1) * 0.5; // 0 a 1
                
                // CPU flutua 2cm acima da placa
                if(window.cpuGroup) {
                    window.cpuGroup.position.y = 0.005 + (float * 0.02);
                    window.cpuGroup.rotation.y = float * 0.2;
                }

                // Cooler flutua 4cm acima da CPU
                if(window.coolerGroup) {
                    window.coolerGroup.position.y = window.cpuGroup.position.y + 0.02 + (float * 0.04);
                    window.coolerGroup.rotation.y = delta * 0.5;
                }
            }

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
