<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Hardware AR - Ultimate</title>
    <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary: #00ff88;
            --glass: rgba(10, 15, 20, 0.80);
            --border: rgba(255, 255, 255, 0.1);
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Rajdhani', sans-serif;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        /* --- UI RESTAURADA (Cyberpunk Dock) --- */

        /* Topo: Informa√ß√µes */
        #info-panel {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 20px;
            box-sizing: border-box;
            background: linear-gradient(to bottom, rgba(0, 0, 0, 0.9), transparent);
            pointer-events: none;
            z-index: 10;
        }

        h1 {
            margin: 0;
            color: white;
            font-size: 24px;
            text-transform: uppercase;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .badge {
            background: var(--primary);
            color: black;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 800;
        }

        #subtitle {
            color: #888;
            font-size: 14px;
            margin-top: 5px;
            font-weight: 600;
        }

        /* Baixo: Doca de Sele√ß√£o */
        #selection-dock {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            padding: 10px 20px;
            background: var(--glass);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border-radius: 24px;
            border: 1px solid var(--border);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            z-index: 20;
        }

        .model-btn {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid transparent;
            color: white;
            width: 55px;
            height: 55px;
            border-radius: 16px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .model-btn.active {
            background: rgba(0, 255, 136, 0.15);
            border-color: var(--primary);
            color: var(--primary);
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(0, 255, 136, 0.2);
        }

        .btn-icon {
            font-size: 20px;
            margin-bottom: 2px;
        }

        .btn-label {
            font-size: 9px;
            font-weight: 700;
            letter-spacing: 1px;
        }

        /* --- GUIAS --- */
        #ar-guide {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid var(--primary);
            color: white;
            padding: 15px 25px;
            border-radius: 50px;
            font-size: 14px;
            font-weight: 600;
            display: none;
            pointer-events: none;
        }

        #loader {
            position: absolute;
            inset: 0;
            background: #000;
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: var(--primary);
            font-size: 12px;
            letter-spacing: 2px;
        }

        .spinner {
            width: 30px;
            height: 30px;
            border: 3px solid #222;
            border-top: 3px solid var(--primary);
            border-radius: 50%;
            animation: spin 1s infinite linear;
            margin-bottom: 15px;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* Bot√£o AR (Customizado) */
        button#ARButton {
            background-color: white !important;
            color: black !important;
            border-radius: 30px !important;
            bottom: 30px !important;
            width: 160px !important;
            font-family: 'Rajdhani' !important;
            font-weight: 800 !important;
            text-transform: uppercase !important;
        }
    </style>
</head>

<body>

    <!-- Topo -->
    <div id="info-panel">
        <h1>
            <span id="model-title">ASUS ROG MAXIMUS</span>
            <span class="badge">AR V3.0</span>
        </h1>
        <div id="subtitle">SISTEMA DE ALTA FIDELIDADE ‚Ä¢ ESCALA 1:1</div>
    </div>

    <!-- Doca Flutuante -->
    <div id="selection-dock">
        <div class="model-btn active" onclick="window.selectModel('mobo')">
            <div class="btn-icon">üéõÔ∏è</div>
            <div class="btn-label">MOBO</div>
        </div>
        <div class="model-btn" onclick="window.selectModel('cpu')">
            <div class="btn-icon">‚ùÑÔ∏è</div>
            <div class="btn-label">COOLER</div>
        </div>
        <div class="model-btn" onclick="window.selectModel('gpu')">
            <div class="btn-icon">üìº</div>
            <div class="btn-label">GPU</div>
        </div>
        <div class="model-btn" onclick="window.selectModel('ram')">
            <div class="btn-icon">üíæ</div>
            <div class="btn-label">RAM</div>
        </div>
    </div>

    <div id="ar-guide">MOVA O CELULAR PARA ESCANEAR...</div>

    <div id="loader">
        <div class="spinner"></div>
        <div>CARREGANDO ASSETS...</div>
    </div>

    <!-- Import Map -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { ARButton } from 'three/addons/webxr/ARButton.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { RoundedBoxGeometry } from 'three/addons/geometries/RoundedBoxGeometry.js';

        // Vari√°veis
        let camera, scene, renderer;
        let contentGroup, reticle;
        let hitTestSource = null, hitTestSourceRequested = false;
        let objectPlaced = false;

        // Anima√ß√£o
        let fans = [];
        let floatParts = [];
        let rgbTextureH, rgbTextureV; // Horizontal e Vertical
        const mats = {};

        try { init(); animate(); } catch (e) { alert(e); }

        function init() {
            const container = document.createElement('div');
            document.body.appendChild(container);

            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

            // Ilumina√ß√£o de Est√∫dio
            const hemi = new THREE.HemisphereLight(0xffffff, 0x222222, 1.0);
            scene.add(hemi);
            const dir = new THREE.DirectionalLight(0xffffff, 3.0);
            dir.position.set(1, 4, 2);
            dir.castShadow = true;
            scene.add(dir);
            const rim = new THREE.SpotLight(0x00ff88, 5.0);
            rim.position.set(-2, 1, -2);
            rim.lookAt(0, 0, 0);
            scene.add(rim);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            renderer.shadowMap.enabled = true;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            container.appendChild(renderer.domElement);

            document.body.appendChild(ARButton.createButton(renderer, {
                requiredFeatures: ['hit-test', 'dom-overlay'],
                domOverlay: { root: document.body }
            }));

            createMaterials();

            contentGroup = new THREE.Group();
            scene.add(contentGroup);

            // Carregar Inicial
            loadObject('mobo');

            // Ret√≠culo
            reticle = new THREE.Mesh(
                new THREE.RingGeometry(0.1, 0.11, 32).rotateX(-Math.PI / 2),
                new THREE.MeshBasicMaterial({ color: 0x00ff88 })
            );
            reticle.matrixAutoUpdate = false;
            reticle.visible = false;
            scene.add(reticle);

            const controller = renderer.xr.getController(0);
            controller.addEventListener('select', onSelect);
            scene.add(controller);

            const controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 0.05, 0);
            controls.update();

            // Eventos AR
            renderer.xr.addEventListener('sessionstart', () => {
                document.getElementById('ar-guide').style.display = 'block';
                document.getElementById('info-panel').style.opacity = '0';
                contentGroup.visible = false;
            });
            renderer.xr.addEventListener('sessionend', () => {
                document.getElementById('ar-guide').style.display = 'none';
                document.getElementById('info-panel').style.opacity = '1';
                contentGroup.visible = true;
                contentGroup.position.set(0, 0, 0);
                camera.position.set(0, 0.3, 0.3);
                camera.lookAt(0, 0, 0);
            });

            window.addEventListener('resize', onWindowResize);
            document.getElementById('loader').style.display = 'none';
        }

        function createMaterials() {
            // 1. Textura PCB Procedural
            const cvs = document.createElement('canvas'); cvs.width = 256; cvs.height = 256;
            const ctx = cvs.getContext('2d');
            ctx.fillStyle = '#050505'; ctx.fillRect(0, 0, 256, 256);
            ctx.strokeStyle = '#222'; ctx.lineWidth = 2;
            for (let i = 0; i < 60; i++) { ctx.beginPath(); ctx.moveTo(Math.random() * 256, Math.random() * 256); ctx.lineTo(Math.random() * 256, Math.random() * 256); ctx.stroke(); }
            const pcbTex = new THREE.CanvasTexture(cvs);

            // 2. RGB Rainbow (Horizontal)
            const cvsH = document.createElement('canvas'); cvsH.width = 256; cvsH.height = 1;
            const ctxH = cvsH.getContext('2d');
            const grdH = ctxH.createLinearGradient(0, 0, 256, 0);
            grdH.addColorStop(0, '#ff0000'); grdH.addColorStop(0.2, '#ffff00'); grdH.addColorStop(0.4, '#00ff00');
            grdH.addColorStop(0.6, '#00ffff'); grdH.addColorStop(0.8, '#0000ff'); grdH.addColorStop(1, '#ff00ff');
            ctxH.fillStyle = grdH; ctxH.fillRect(0, 0, 256, 1);
            rgbTextureH = new THREE.CanvasTexture(cvsH);
            rgbTextureH.wrapS = THREE.RepeatWrapping;

            // 3. RGB Rainbow (Vertical - Rotacionado)
            // Criamos uma textura onde o gradiente √© vertical para mapear corretamente em pe√ßas "em p√©"
            const cvsV = document.createElement('canvas'); cvsV.width = 1; cvsV.height = 256;
            const ctxV = cvsV.getContext('2d');
            const grdV = ctxV.createLinearGradient(0, 0, 0, 256);
            grdV.addColorStop(0, '#ff0000'); grdV.addColorStop(0.2, '#ffff00'); grdV.addColorStop(0.4, '#00ff00');
            grdV.addColorStop(0.6, '#00ffff'); grdV.addColorStop(0.8, '#0000ff'); grdV.addColorStop(1, '#ff00ff');
            ctxV.fillStyle = grdV; ctxV.fillRect(0, 0, 1, 256);
            rgbTextureV = new THREE.CanvasTexture(cvsV);
            rgbTextureV.wrapT = THREE.RepeatWrapping;

            // Materiais
            mats.pcb = new THREE.MeshStandardMaterial({ map: pcbTex, roughness: 0.5, metalness: 0.2 });
            mats.metal = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.2, metalness: 0.9 });
            mats.alum = new THREE.MeshStandardMaterial({ color: 0xdddddd, roughness: 0.3, metalness: 0.8 });
            mats.gold = new THREE.MeshStandardMaterial({ color: 0xffcc00, roughness: 0.1, metalness: 1.0 });
            mats.copper = new THREE.MeshStandardMaterial({ color: 0xb87333, roughness: 0.4, metalness: 0.6 });
            mats.blackPlastic = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.8, metalness: 0.1 });
            mats.capBody = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.3, metalness: 0.5 });

            // Dois materiais RGB: Um para an√©is/tiras horizontais, outro para barras verticais
            mats.rgbH = new THREE.MeshBasicMaterial({ map: rgbTextureH });
            mats.rgbV = new THREE.MeshBasicMaterial({ map: rgbTextureV });
        }

        // --- FUN√á√ÉO DE TROCA ---
        window.selectModel = function (type) {
            document.querySelectorAll('.model-btn').forEach(b => b.classList.remove('active'));
            event.currentTarget.classList.add('active');

            const titles = {
                'mobo': ['ASUS ROG MAXIMUS', 'E-ATX ‚Ä¢ Z790 CHIPSET'],
                'cpu': ['RYZEN 9 + COOLER', 'VISTA EXPLODIDA ‚Ä¢ TOWER'],
                'gpu': ['RTX 4090 SUPRIM', '24GB GDDR6X ‚Ä¢ FLOW THROUGH'],
                'ram': ['TRIDENT Z5 RGB', 'DDR5 6400MHZ ‚Ä¢ CL32']
            };
            document.getElementById('model-title').innerText = titles[type][0];
            document.getElementById('subtitle').innerText = titles[type][1];

            loadObject(type);
        }

        function loadObject(type) {
            contentGroup.clear();
            fans = []; floatParts = [];

            if (type === 'mobo') buildMobo();
            if (type === 'cpu') buildCPU_Cooler();
            if (type === 'gpu') buildGPU();
            if (type === 'ram') buildRAM();
        }

        // --- CONSTRUTORES ---

        function buildMobo() {
            const g = new THREE.Group();
            // PCB (30x24cm)
            const pcb = new THREE.Mesh(new RoundedBoxGeometry(0.24, 0.004, 0.30, 2, 0.01), mats.pcb);
            pcb.receiveShadow = true; g.add(pcb);

            // VRM Heatsinks (Robustos com aletas)
            const vrmGroup = new THREE.Group();

            // Top Heatsink
            const vrm1 = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.03, 0.14), mats.metal);
            vrm1.position.set(-0.08, 0.015, -0.05); vrmGroup.add(vrm1);
            // Detalhe RGB no VRM
            const vrmStrip = new THREE.Mesh(new THREE.BoxGeometry(0.042, 0.005, 0.10), mats.rgbH);
            vrmStrip.position.set(-0.08, 0.02, -0.05); vrmGroup.add(vrmStrip);

            // Left Heatsink
            const vrm2 = new THREE.Mesh(new THREE.BoxGeometry(0.14, 0.03, 0.04), mats.metal);
            vrm2.position.set(0, 0.015, -0.10); vrmGroup.add(vrm2);
            g.add(vrmGroup);

            // Capacitores (Cil√≠ndricos)
            const capGeo = new THREE.CylinderGeometry(0.004, 0.004, 0.01, 16);
            for (let i = 0; i < 8; i++) {
                const cap = new THREE.Mesh(capGeo, mats.capBody);
                cap.rotation.x = Math.PI / 2;
                cap.position.set(-0.05, 0.008, -0.08 + (i * 0.015));
                const capTop = new THREE.Mesh(new THREE.CylinderGeometry(0.004, 0.004, 0.001, 16), mats.alum);
                capTop.position.y = 0.005; cap.add(capTop);
                g.add(cap);
            }

            // Chipset Heatsink
            const chipset = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.015, 0.08), mats.metal);
            chipset.position.set(0.05, 0.01, 0.08);
            g.add(chipset);
            // Olho ROG (Simulado com plano RGB)
            const eye = new THREE.Mesh(new THREE.PlaneGeometry(0.04, 0.04), mats.rgbV);
            eye.rotation.x = -Math.PI / 2; eye.position.set(0.05, 0.018, 0.08);
            g.add(eye);

            // Logo I/O (RGB Vertical)
            const io = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.04, 0.14), mats.blackPlastic);
            io.position.set(-0.09, 0.02, -0.05); g.add(io);
            const logo = new THREE.Mesh(new THREE.PlaneGeometry(0.03, 0.08), mats.rgbV); // Vertical
            logo.rotation.x = -Math.PI / 2; logo.position.set(-0.09, 0.041, -0.05);
            g.add(logo);

            // PCIe Slots (Metal refor√ßado)
            for (let i = 0; i < 3; i++) {
                const s = new THREE.Mesh(new THREE.BoxGeometry(0.16, 0.008, 0.012), mats.alum);
                s.position.set(0.01, 0.006, 0.04 + (i * 0.06)); g.add(s);
                // Trava do slot
                const latch = new THREE.Mesh(new THREE.BoxGeometry(0.01, 0.008, 0.012), mats.blackPlastic);
                latch.position.set(0.09, 0.006, 0.04 + (i * 0.06)); g.add(latch);
            }
            contentGroup.add(g);
        }

        function buildCPU_Cooler() {
            const g = new THREE.Group();

            // CPU
            const cpu = new THREE.Group();
            cpu.add(new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.002, 0.04), mats.pcb));
            const ihs = new THREE.Mesh(new THREE.BoxGeometry(0.034, 0.004, 0.034), mats.alum);
            ihs.position.y = 0.003; cpu.add(ihs);
            g.add(cpu);

            // Cooler
            const cooler = new THREE.Group();
            cooler.add(new THREE.Mesh(new THREE.BoxGeometry(0.045, 0.005, 0.045), mats.copper));
            // Aletas
            const stack = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.10, 0.05), mats.alum);
            stack.position.y = 0.06; cooler.add(stack);

            // Fan
            const fanFrame = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.12, 0.02), mats.metal);
            fanFrame.position.set(0, 0.06, 0.04); cooler.add(fanFrame);

            // H√©lice (Piv√¥ Centralizado)
            const fanGroup = new THREE.Group();
            fanGroup.position.set(0, 0.06, 0.052);

            // RGB Ring (Est√°tico no frame, mas vamos por nas p√°s para efeito legal)
            for (let k = 0; k < 9; k++) {
                const b = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.012, 0.002), mats.rgbH); // Horizontal map
                b.position.x = 0.03; b.rotation.x = 0.4;
                const p = new THREE.Group();
                p.rotation.z = (k / 9) * Math.PI * 2;
                p.add(b);
                fanGroup.add(p);
            }
            cooler.add(fanGroup);
            fans.push(fanGroup);

            // Anima√ß√£o Levitar
            cpu.userData = { baseY: 0.01, floatH: 0.02 }; floatParts.push(cpu);
            cooler.userData = { baseY: 0.005, floatH: 0.08 }; floatParts.push(cooler);
            g.add(cooler);
            contentGroup.add(g);
        }

        function buildGPU() {
            const g = new THREE.Group();

            // Corpo Principal
            const body = new THREE.Mesh(new RoundedBoxGeometry(0.32, 0.055, 0.13, 4, 0.01), mats.metal);
            body.position.y = 0.03; body.castShadow = true; g.add(body);

            // Backplate
            const backplate = new THREE.Mesh(new RoundedBoxGeometry(0.32, 0.004, 0.13, 4, 0.01), mats.alum);
            backplate.position.y = 0.06; g.add(backplate);
            // Detalhe vazado no backplate (simulado com cor escura)
            const vent = new THREE.Mesh(new THREE.PlaneGeometry(0.08, 0.1), mats.blackPlastic);
            vent.rotation.x = -Math.PI / 2; vent.position.set(0.1, 0.063, 0); g.add(vent);

            // Heatpipes
            const pipeGeo = new THREE.CylinderGeometry(0.003, 0.003, 0.1, 8);
            for (let i = 0; i < 4; i++) {
                const pipe = new THREE.Mesh(pipeGeo, mats.copper);
                pipe.rotation.z = Math.PI / 2;
                pipe.position.set(0, 0.03, -0.05 + (i * 0.03));
                g.add(pipe);
            }

            // Strip Lateral (RGB Horizontal)
            const strip = new THREE.Mesh(new THREE.BoxGeometry(0.28, 0.005, 0.002), mats.rgbH);
            strip.position.set(0, 0.03, 0.066); // 0.5mm pra fora da face
            g.add(strip);

            // Fans
            for (let i = -1; i <= 1; i++) {
                const xPos = i * 0.095;

                // Moldura do Fan
                const ring = new THREE.Mesh(new THREE.TorusGeometry(0.042, 0.003, 16, 32), mats.alum);
                ring.rotation.x = -Math.PI / 2;
                ring.position.set(xPos, 0.058, 0);
                g.add(ring);

                // H√©lice (Gira)
                const fGroup = new THREE.Group();
                for (let k = 0; k < 11; k++) { // Mais p√°s
                    // P√°s curvas
                    const b = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.008, 0.001), mats.blackPlastic);
                    b.position.x = 0.022;
                    b.rotation.x = 0.4; // Angulo de ataque

                    const p = new THREE.Group();
                    p.rotation.z = (k / 11) * Math.PI * 2;
                    p.add(b);
                    fGroup.add(p);
                }
                // Centro do Fan
                const hub = new THREE.Mesh(new THREE.CylinderGeometry(0.01, 0.01, 0.005, 16), mats.metal);
                hub.rotation.x = Math.PI / 2; fGroup.add(hub);
                // Logo no centro
                const sticker = new THREE.Mesh(new THREE.CircleGeometry(0.008, 16), mats.alum);
                sticker.position.z = 0.003; fGroup.add(sticker);

                fGroup.rotation.x = -Math.PI / 2;
                fGroup.position.set(xPos, 0.055, 0);
                g.add(fGroup);
                fans.push(fGroup);
            }
            g.rotation.x = -Math.PI / 2; g.position.y = 0.02;
            contentGroup.add(g);
        }

        function buildRAM() {
            const g = new THREE.Group();
            for (let i = -1; i <= 1; i += 2) {
                const stick = new THREE.Group();
                // PCB Base
                stick.add(new THREE.Mesh(new THREE.BoxGeometry(0.133, 0.035, 0.002), mats.pcb));

                // Heat Spreader (Angular)
                const heatGeo = new THREE.BufferGeometry();
                // Simplificado: Box com escala
                const heat = new THREE.Mesh(new THREE.BoxGeometry(0.135, 0.032, 0.006), mats.alum);
                heat.position.y = 0.002;
                stick.add(heat);

                // Detalhe preto no meio
                const detail = new THREE.Mesh(new THREE.BoxGeometry(0.136, 0.01, 0.007), mats.blackPlastic);
                detail.position.y = 0.002;
                stick.add(detail);

                // Barra RGB Topo (Estilo Trident Z)
                // Formato de "cristal"
                const rgb = new THREE.Mesh(new THREE.BoxGeometry(0.135, 0.008, 0.006), mats.rgbH);
                rgb.position.y = 0.02;
                stick.add(rgb);

                stick.position.z = i * 0.01;
                g.add(stick);
            }
            g.position.y = 0.05;
            contentGroup.add(g);
        }

        // --- LOOP ---
        function onSelect() {
            if (reticle.visible) {
                const p = new THREE.Vector3(); camera.getWorldPosition(p);
                contentGroup.position.setFromMatrixPosition(reticle.matrix);
                if (Math.abs(p.x - contentGroup.position.x) > 0.01) contentGroup.lookAt(p.x, contentGroup.position.y, p.z);

                contentGroup.visible = true;
                objectPlaced = true;
                document.getElementById('ar-guide').innerText = "OBJETO FIXADO";
                setTimeout(() => document.getElementById('ar-guide').style.display = 'none', 2000);
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            renderer.setAnimationLoop(render);
        }

        function render(timestamp, frame) {
            const t = timestamp / 1000;

            if (frame) {
                const session = renderer.xr.getSession();
                if (!hitTestSourceRequested) {
                    session.requestReferenceSpace('viewer').then(ref =>
                        session.requestHitTestSource({ space: ref }).then(source => hitTestSource = source));
                    hitTestSourceRequested = true;
                }
                if (hitTestSource) {
                    const hits = frame.getHitTestResults(hitTestSource);
                    if (hits.length > 0) {
                        reticle.visible = true;
                        reticle.matrix.fromArray(hits[0].getPose(renderer.xr.getReferenceSpace()).transform.matrix);
                        if (!objectPlaced) document.getElementById('ar-guide').innerText = "TOQUE PARA POSICIONAR";
                    } else reticle.visible = false;
                }
            }

            if (contentGroup.visible || !renderer.xr.isPresenting) {
                fans.forEach(f => f.rotation.z -= 0.2);

                floatParts.forEach(p => p.position.y = p.userData.baseY + (Math.sin(t * 2) * 0.5 + 0.5) * p.userData.floatH);

                // Animar Texturas RGB
                if (rgbTextureH) rgbTextureH.offset.x -= 0.01; // Corre de lado
                if (rgbTextureV) rgbTextureV.offset.y -= 0.01; // Corre pra cima

                if (!renderer.xr.isPresenting) contentGroup.rotation.y += 0.003;
            }
            renderer.render(scene, camera);
        }
    </script>
</body>

</html>
