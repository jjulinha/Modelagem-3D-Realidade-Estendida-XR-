<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Hardware AR - Ultra Detail</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;900&family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <style>
        :root { --primary: #00f3ff; --glass: rgba(15, 15, 20, 0.9); }
        body { margin: 0; overflow: hidden; background: #050505; font-family: 'Inter', sans-serif; user-select: none; }
        
        /* UI Superior */
        #ui-top {
            position: absolute; top: 0; left: 0; width: 100%;
            padding: 20px; box-sizing: border-box;
            display: flex; justify-content: center; gap: 15px;
            z-index: 10; pointer-events: none;
            background: linear-gradient(to bottom, rgba(0,0,0,0.9), transparent);
        }

        .selector-btn {
            pointer-events: auto;
            width: 70px; height: 70px;
            background: rgba(255,255,255,0.05);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 16px;
            color: #888; cursor: pointer;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        .selector-btn i { font-size: 24px; margin-bottom: 4px; filter: grayscale(1); transition: 0.3s; }
        .selector-btn span { font-size: 10px; font-weight: 700; letter-spacing: 1px; }

        .selector-btn.active {
            border-color: var(--primary);
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.3);
            transform: translateY(5px);
            color: white;
        }
        .selector-btn.active i { filter: grayscale(0); text-shadow: 0 0 10px var(--primary); }

        /* Loader & Hints */
        #loader {
            position: absolute; inset: 0; background: #020202; z-index: 100;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: var(--primary); font-family: 'Orbitron';
        }
        .spinner {
            width: 40px; height: 40px; border: 4px solid #333;
            border-top-color: var(--primary); border-radius: 50%;
            animation: spin 1s infinite linear; margin-bottom: 20px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        #ar-hint {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8); border: 1px solid var(--primary);
            color: white; padding: 15px 30px; border-radius: 30px;
            font-weight: 600; display: none; pointer-events: none;
        }

        /* Ajuste bot√£o AR */
        button#ARButton {
            bottom: 40px !important; width: 200px !important;
            background: var(--primary) !important; color: black !important;
            font-family: 'Orbitron' !important; font-weight: 900 !important;
            border-radius: 4px !important; border: none !important;
            clip-path: polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%);
        }
    </style>
</head>
<body>

    <div id="ui-top">
        <div class="selector-btn active" onclick="loadObj('mobo')">
            <i>üéõÔ∏è</i><span>MOBO</span>
        </div>
        <div class="selector-btn" onclick="loadObj('gpu')">
            <i>üìº</i><span>GPU</span>
        </div>
        <div class="selector-btn" onclick="loadObj('ram')">
            <i>üíæ</i><span>RAM</span>
        </div>
        <div class="selector-btn" onclick="loadObj('cooler')">
            <i>‚ùÑÔ∏è</i><span>COOLER</span>
        </div>
    </div>

    <div id="ar-hint">Detectando ch√£o...</div>
    <div id="loader"><div class="spinner"></div>GERANDO ASSETS...</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { ARButton } from 'three/addons/webxr/ARButton.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { RoundedBoxGeometry } from 'three/addons/geometries/RoundedBoxGeometry.js';

        let camera, scene, renderer;
        let contentGroup, reticle;
        let hitTestSource = null, hitTestSourceRequested = false;
        let objectPlaced = false;
        let animatedParts = []; // Array para guardar coisas que giram

        // Cache de Materiais
        const mats = {};

        init();
        animate();

        function init() {
            const container = document.createElement('div');
            document.body.appendChild(container);

            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

            // Ilumina√ß√£o High-End
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x222222, 0.8);
            scene.add(hemiLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 2.5);
            dirLight.position.set(1, 4, 2);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            container.appendChild(renderer.domElement);

            // Bot√£o AR
            document.body.appendChild(ARButton.createButton(renderer, { 
                requiredFeatures: ['hit-test', 'dom-overlay'],
                domOverlay: { root: document.body }
            }));

            // Materiais
            createMaterials();

            // Grupo Principal
            contentGroup = new THREE.Group();
            scene.add(contentGroup);

            // Carregar Padr√£o
            loadObj('mobo');

            // Ret√≠culo
            reticle = new THREE.Mesh(
                new THREE.RingGeometry(0.1, 0.11, 32).rotateX(-Math.PI / 2),
                new THREE.MeshBasicMaterial({ color: 0x00f3ff })
            );
            reticle.matrixAutoUpdate = false;
            reticle.visible = false;
            scene.add(reticle);

            // Intera√ß√£o
            const controller = renderer.xr.getController(0);
            controller.addEventListener('select', onSelect);
            scene.add(controller);

            // Controles PC
            const controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 0.05, 0);
            controls.update();

            // Listeners
            renderer.xr.addEventListener('sessionstart', () => {
                document.getElementById('ar-hint').style.display = 'block';
                contentGroup.visible = false;
                objectPlaced = false;
            });
            
            window.addEventListener('resize', onWindowResize);
            document.getElementById('loader').style.display = 'none';

            // Expor fun√ß√£o global para os bot√µes HTML
            window.loadObj = (type) => {
                // UI Updates
                document.querySelectorAll('.selector-btn').forEach(b => b.classList.remove('active'));
                event.currentTarget.classList.add('active');
                
                // Logic
                contentGroup.clear();
                animatedParts = []; // Limpa lista de anima√ß√£o

                let mesh;
                if(type === 'mobo') mesh = buildDetailedMobo();
                if(type === 'gpu') mesh = buildDetailedGPU();
                if(type === 'ram') mesh = buildDetailedRAM();
                if(type === 'cooler') mesh = buildDetailedCooler();
                
                contentGroup.add(mesh);
            };
        }

        function createMaterials() {
            // Textura PCB Procedural de Alta Resolu√ß√£o
            const canvas = document.createElement('canvas'); canvas.width = 1024; canvas.height = 1024;
            const ctx = canvas.getContext('2d');
            // Base
            ctx.fillStyle = '#1a1a1a'; ctx.fillRect(0,0,1024,1024);
            // Traces
            ctx.strokeStyle = '#2a2a2a'; ctx.lineWidth = 3;
            for(let i=0; i<300; i++) {
                ctx.beginPath(); 
                const x = Math.random()*1024; const y = Math.random()*1024;
                ctx.moveTo(x, y);
                if(Math.random()>0.5) ctx.lineTo(x + (Math.random()*200-100), y);
                else ctx.lineTo(x, y + (Math.random()*200-100));
                ctx.stroke();
            }
            // ICs / Chips
            ctx.fillStyle = '#050505';
            for(let i=0; i<50; i++) {
                ctx.fillRect(Math.random()*1000, Math.random()*1000, 20, 20);
            }
            const pcbMap = new THREE.CanvasTexture(canvas);

            mats.pcb = new THREE.MeshStandardMaterial({ map: pcbMap, roughness: 0.6, metalness: 0.1 });
            mats.metalDark = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.2, metalness: 0.8 });
            mats.aluminum = new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.3, metalness: 0.7 });
            mats.heatsink = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.4, metalness: 0.6 });
            mats.copper = new THREE.MeshStandardMaterial({ color: 0xb87333, roughness: 0.3, metalness: 0.8 });
            mats.plastic = new THREE.MeshStandardMaterial({ color: 0x050505, roughness: 0.5 });
            mats.gold = new THREE.MeshStandardMaterial({ color: 0xffcc00, roughness: 0.2, metalness: 1.0 });
            mats.rgb = new THREE.MeshStandardMaterial({ color: 0x000000, emissive: 0x00f3ff, emissiveIntensity: 2 });
        }

        // --- CONSTRUTORES 3D DE ALTA FIDELIDADE ---

        function buildDetailedMobo() {
            const g = new THREE.Group();
            
            // PCB Principal (ATX)
            const pcb = new THREE.Mesh(new RoundedBoxGeometry(0.24, 0.004, 0.30, 4, 0.01), mats.pcb);
            pcb.receiveShadow = true; pcb.castShadow = true;
            g.add(pcb);

            // Heatsinks VRM (Geometria Complexa)
            const shape = new THREE.Shape();
            shape.moveTo(0,0); shape.lineTo(0.03, 0); shape.lineTo(0.03, 0.10); shape.lineTo(0, 0.10);
            const extrudeSettings = { depth: 0.03, bevelEnabled: true, bevelSize: 0.002, bevelThickness: 0.002 };
            const vrmGeo = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            const vrmLeft = new THREE.Mesh(vrmGeo, mats.heatsink);
            vrmLeft.rotation.x = -Math.PI/2; // Deitar para extrudar pra cima
            vrmLeft.position.set(-0.09, 0.002, 0.04); // Ajuste fino
            g.add(vrmLeft);

            // Slots de RAM (4 pentes)
            const slotGeo = new THREE.BoxGeometry(0.008, 0.01, 0.13);
            for(let i=0; i<4; i++) {
                const slot = new THREE.Mesh(slotGeo, mats.plastic);
                slot.position.set(0.03 + (i*0.012), 0.005, -0.05);
                g.add(slot);
            }

            // Socket CPU (Detalhe)
            const socket = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.005, 0.06), mats.plastic);
            socket.position.set(-0.03, 0.004, -0.05);
            g.add(socket);
            const latch = new THREE.Mesh(new THREE.BoxGeometry(0.005, 0.004, 0.07), mats.aluminum);
            latch.position.set(0.005, 0.004, -0.05);
            g.add(latch);

            // Capacitores de √Åudio (Cilindros dourados)
            const capGeo = new THREE.CylinderGeometry(0.004, 0.004, 0.008, 16);
            for(let i=0; i<5; i++) {
                const cap = new THREE.Mesh(capGeo, mats.gold);
                cap.position.set(-0.09 + (i*0.006), 0.006, 0.12);
                g.add(cap);
            }

            // Chipset com Logo RGB
            const chipset = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.01, 0.06), mats.heatsink);
            chipset.position.set(0.05, 0.006, 0.08);
            g.add(chipset);
            const logo = new THREE.Mesh(new THREE.PlaneGeometry(0.04, 0.02), mats.rgb);
            logo.rotation.x = -Math.PI/2;
            logo.position.set(0.05, 0.012, 0.08);
            g.add(logo);

            return g;
        }

        function buildDetailedGPU() {
            const g = new THREE.Group();
            
            // Carenagem Principal (Shroud) - Curvas
            const shroudShape = new THREE.Shape();
            shroudShape.moveTo(0,0);
            shroudShape.lineTo(0.28, 0);
            shroudShape.lineTo(0.30, 0.02); // Bico angulado
            shroudShape.lineTo(0.30, 0.11);
            shroudShape.lineTo(0, 0.13);
            const shroudGeo = new THREE.ExtrudeGeometry(shroudShape, { depth: 0.05, bevelEnabled: true, bevelSize: 0.005 });
            const shroud = new THREE.Mesh(shroudGeo, mats.metalDark);
            shroud.rotation.x = Math.PI/2; 
            shroud.position.set(-0.15, 0.05, 0.06); // Centralizar
            g.add(shroud);

            // Ventoinhas (Fans) - CORRE√á√ÉO DE ROTA√á√ÉO
            // Criamos a geometria da ventoinha centrada em (0,0,0)
            const fanGroupGeo = new THREE.Group();
            const hub = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 0.01, 16), mats.plastic);
            fanGroupGeo.add(hub);
            
            const bladeGeo = new THREE.BoxGeometry(0.04, 0.002, 0.01);
            for(let i=0; i<9; i++) {
                const blade = new THREE.Mesh(bladeGeo, mats.plastic);
                blade.position.set(0.025, 0, 0); // Afasta do centro
                
                // Piv√¥ auxiliar para girar a p√°
                const pivot = new THREE.Group();
                pivot.rotation.y = (i/9) * Math.PI * 2; // Gira ao redor do centro
                pivot.add(blade);
                
                blade.rotation.x = 0.4; // Inclina√ß√£o da p√° (vento)
                fanGroupGeo.add(pivot);
            }

            // Adicionar 3 fans posicionadas corretamente no Shroud
            for(let i=0; i<3; i++) {
                const fan = fanGroupGeo.clone();
                // Posicionar a fan no local final
                fan.position.set((i * 0.095) - 0.095, 0.051, 0.065); // Y √© altura do ch√£o, Z √© profundidade
                fan.rotation.x = Math.PI/2; // Virar para frente
                
                g.add(fan);
                animatedParts.push(fan); // Adiciona √† lista de rota√ß√£o
                
                // Anel RGB ao redor da fan
                const ring = new THREE.Mesh(new THREE.TorusGeometry(0.042, 0.001, 16, 32), mats.rgb);
                ring.position.copy(fan.position);
                ring.rotation.x = Math.PI/2;
                g.add(ring);
            }

            // Backplate
            const plate = new THREE.Mesh(new THREE.BoxGeometry(0.30, 0.13, 0.002), mats.aluminum);
            plate.rotation.x = Math.PI/2;
            plate.position.set(0, 0.10, 0);
            g.add(plate);

            // Posi√ß√£o final da GPU no mundo
            g.position.y = 0.02;

            return g;
        }

        function buildDetailedCooler() {
            const g = new THREE.Group();

            // Base contato
            const base = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.01, 0.04), mats.copper);
            g.add(base);

            // Heatpipes
            const pipeGeo = new THREE.CylinderGeometry(0.003, 0.003, 0.15, 16);
            for(let i=0; i<4; i++) {
                const p = new THREE.Mesh(pipeGeo, mats.copper);
                p.position.set((i*0.01)-0.015, 0.07, 0);
                g.add(p);
            }

            // Aletas (Fins) - Alta densidade
            const finGeo = new THREE.BoxGeometry(0.06, 0.001, 0.12);
            const finsGroup = new THREE.Group();
            for(let i=0; i<40; i++) {
                const fin = new THREE.Mesh(finGeo, mats.aluminum);
                fin.position.y = 0.02 + (i*0.0035);
                finsGroup.add(fin);
            }
            g.add(finsGroup);

            // Fan frontal (separada para girar certo)
            const fanFrame = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.12, 0.025), mats.plastic);
            fanFrame.position.set(0, 0.08, 0.075);
            g.add(fanFrame);

            // H√©lice RGB
            const bladeGeo = new THREE.CylinderGeometry(0.055, 0.055, 0.005, 8, 1, true);
            // Textura de h√©lice r√°pida (blur)
            const bladeMat = new THREE.MeshBasicMaterial({ 
                color: 0x00f3ff, side: THREE.DoubleSide, transparent: true, opacity: 0.8 
            });
            const blade = new THREE.Mesh(bladeGeo, bladeMat);
            blade.rotation.x = Math.PI/2;
            
            // O Ponto chave: O objeto 'blade' tem centro em 0,0,0. 
            // Movemos ele para a posi√ß√£o final DENTRO do grupo, mas n√£o o transformamos.
            // Para animar, vamos criar um pivot.
            
            const pivot = new THREE.Group();
            pivot.position.set(0, 0.08, 0.088); // Posi√ß√£o final do centro da ventoinha
            pivot.add(blade); // Adiciona blade no centro do pivot
            
            g.add(pivot);
            // Agora giramos o pivot.blade (que est√° em 0 relative ao pivot)
            // Ops, blade geometry √© cilindro. Vamos fazer p√°s reais pra ficar bonito.
            
            pivot.remove(blade); // Remove o cilindro feio
            
            // Criar p√°s reais no pivot
            for(let i=0; i<7; i++) {
                const b = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.05, 0.002), mats.rgb);
                b.position.y = 0.03; // Afasta do centro
                const p = new THREE.Group();
                p.rotation.z = (i/7)*Math.PI*2;
                p.add(b);
                pivot.add(p);
            }
            
            g.add(pivot);
            animatedParts.push(pivot); // Adiciona o PIVOT √† lista de anima√ß√£o

            g.position.y = 0.005;
            return g;
        }

        function buildDetailedRAM() {
            const g = new THREE.Group();
            // Pente 1
            const s1 = createStick();
            s1.position.z = -0.01;
            g.add(s1);
            // Pente 2
            const s2 = createStick();
            s2.position.z = 0.01;
            g.add(s2);
            
            g.position.y = 0.03;
            return g;
        }

        function createStick() {
            const s = new THREE.Group();
            // PCB
            const pcb = new THREE.Mesh(new THREE.BoxGeometry(0.133, 0.035, 0.002), mats.pcb);
            s.add(pcb);
            // Dissipador (Alum√≠nio escovado com relevo)
            const heatL = new THREE.Mesh(new THREE.BoxGeometry(0.133, 0.03, 0.004), mats.aluminum);
            heatL.position.set(0, 0.002, 0.003);
            s.add(heatL);
            const heatR = new THREE.Mesh(new THREE.BoxGeometry(0.133, 0.03, 0.004), mats.aluminum);
            heatR.position.set(0, 0.002, -0.003);
            s.add(heatR);
            // RGB Diffuser Topo
            const rgb = new THREE.Mesh(new THREE.BoxGeometry(0.133, 0.005, 0.01), mats.rgb);
            rgb.position.y = 0.018;
            s.add(rgb);
            return s;
        }

        // --- L√ìGICA CORE ---

        function onSelect() {
            if (reticle.visible) {
                contentGroup.position.setFromMatrixPosition(reticle.matrix);
                // Virar para usu√°rio
                const p = new THREE.Vector3(); camera.getWorldPosition(p);
                contentGroup.lookAt(p.x, contentGroup.position.y, p.z);
                
                contentGroup.visible = true;
                objectPlaced = true;
                document.getElementById('ar-hint').innerText = "Objeto fixado!";
                setTimeout(() => document.getElementById('ar-hint').style.display='none', 2000);
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            renderer.setAnimationLoop(render);
        }

        function render(timestamp, frame) {
            // Hit Test AR
            if (frame) {
                const session = renderer.xr.getSession();
                if (!hitTestSourceRequested) {
                    session.requestReferenceSpace('viewer').then(ref => 
                        session.requestHitTestSource({ space: ref }).then(source => hitTestSource = source));
                    hitTestSourceRequested = true;
                }
                if (hitTestSource) {
                    const hits = frame.getHitTestResults(hitTestSource);
                    if (hits.length > 0) {
                        const hit = hits[0];
                        reticle.visible = true;
                        reticle.matrix.fromArray(hit.getPose(renderer.xr.getReferenceSpace()).transform.matrix);
                        if(!objectPlaced) document.getElementById('ar-hint').innerText = "Toque para posicionar";
                    } else reticle.visible = false;
                }
            }

            // Anima√ß√µes
            if(contentGroup.visible || !renderer.xr.isPresenting) {
                // Girar pe√ßas animadas (Fans)
                animatedParts.forEach(part => {
                    // O eixo de rota√ß√£o depende de como constru√≠mos.
                    // Fans da GPU foram giradas no X para ficarem de p√©, ent√£o giram no Z local?
                    // Vamos testar rota√ß√£o Z local
                    part.rotateZ(-0.15); 
                });

                // Rota√ß√£o suave Showcase no PC
                if(!renderer.xr.isPresenting) contentGroup.rotation.y += 0.002;
            }

            renderer.render(scene, camera);
        }

    </script>
</body>
</html>


